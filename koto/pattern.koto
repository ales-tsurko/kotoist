import koto
from test import assert, assert_eq, assert_near
from number import infinity

as_iter = |value|
  if koto.type(value) == "Iterator"
    loop
      next = value.next()
      if next == () then break
      yield next
  else
    loop
      yield value

rrand = |min, max|
  return (random.number() * (max - min)) + min

rand = |val|
  return random.number() * val

rand2 = |val|
  return random.number() * val * 2 - val

exprand = |lo, hi|
  return lo * ((hi / lo).ln() * random.number()).exp()

fold = |val, lo, hi|
  x = val - lo

  # avoid the divide if possible
  if val >= hi 
    val = hi + hi - val
    if val >= lo
      return val
  else if val < lo
    val = lo + lo - val
    if val < hi
      return val
  else
    return val

  if hi == lo
    return lo

  # ok do the divide
  range = hi - lo
  range2 = range + range
  c = x - range2 * (x / range2).floor()
  if c >= range
    c = range2 - c

  return c + lo

round = |val, quant|
  if quant == 0.0 then val else (val / quant + 0.5).floor() * quant

pbeta = |lo, hi, prob1, prob2, length|
  lo_iter = as_iter lo
  hi_iter = as_iter hi
  prob1_iter = as_iter prob1
  prob2_iter = as_iter prob2
  lo_val = ()
  hi_val = ()

  while length > 0
    rprob1 = prob1_iter.next()
    rprob2 = prob2_iter.next()

    if rprob1 == () or rprob2 == ()
      yield ()
      break

    rprob1 = rprob1.recip()
    rprob2 = rprob2.recip()

    lo_val = lo_iter.next()
    hi_val = hi_iter.next()

    if lo_val == () or hi_val == ()
      yield ()
      break

    sum = 2
    temp = 0

    while sum > 1
      temp = random.number().pow(rprob1)
      sum = temp + random.number().pow(rprob2)

    yield ((temp / sum) * (hi_val - lo_val)) + lo_val

    length -= 1

pbrown = |lo, hi, step, length|
  lo_iter = as_iter lo
  hi_iter = as_iter hi
  step_iter = as_iter step

  lo_val = lo_iter.next()
  hi_val = hi_iter.next()
  step_val = step_iter.next()

  if lo_val == () or hi_val == () or step_val == ()
    yield ()
    return

  cur = rrand lo_val, hi_val

  while length > 0
    lo_val = lo_iter.next()
    hi_val = hi_iter.next()
    step_val = step_iter.next()

    if lo_val == () or hi_val == () or step_val == ()
      yield ()
      break

    next = cur + rand2(step_val)
    cur = fold(next, lo_val, hi_val)

    yield cur

    length -= 1

pgbrown = |lo, hi, step, length|
  lo_iter = as_iter lo
  hi_iter = as_iter hi
  step_iter = as_iter step

  lo_val = lo_iter.next()
  hi_val = hi_iter.next()
  step_val = step_iter.next()

  if lo_val == () or hi_val == () or step_val == ()
    yield ()
    return

  cur = rrand lo_val, hi_val

  while length > 0
    lo_val = lo_iter.next()
    hi_val = hi_iter.next()
    step_val = step_iter.next()

    if lo_val == () or hi_val == () or step_val == ()
      yield ()
      break

    next = cur * (1 + rand2(step_val))
    cur = fold(next, lo_val, hi_val)

    yield cur

    length -= 1

pcauchy = |mean, spread, length|
  mean_iter = as_iter mean
  spread_iter = as_iter spread
  mean_val = ()
  spread_val = ()

  while length > 0
    ran = 0.5
    mean_val = mean_iter.next()
    spread_val = spread_iter.next()

    if mean_val == () or spread_val == ()
      yield ()
      break

    while ran == 0.5
      ran = random.number()

    yield ((ran * number.pi).tan() * spread_val) + mean_val

    length -= 1

pclump = |n, pattern|
  li = []

  loop
    next = pattern.next()

    if next == ()
      yield li
      break

    li.push next

    if li.size() == n
      yield li
      li = []

pclutch = |pattern, connected|
  val = ()

  loop
    is_con = connected.next()

    if is_con == ()
      yield ()
      break
    else if is_con
      val = pattern.next()
      yield val
      if val == ()
        break
    else
      yield val

pconst = |sum, pattern, tollerance|
  iter = as_iter pattern
  delta = ()
  elapsed = 0.0
  next_elapsed = ()

  loop 
    delta = iter.next()

    if delta == ()
      yield sum - elapsed
      break

    next_elapsed = elapsed + delta

    if round(next_elapsed, tollerance) >= sum
      yield sum - elapsed
      break
    else
      elapsed = next_elapsed
      yield delta

pdup = |n, pattern|
  if koto.type(n) == "Iterator"
    loop
      times = n.next()
      if times == () then break
      val = pattern.next()
      if val == () then break
      while times > 0
        yield val
        times -= 1
  else 
    val = pattern.next()
    if val == () then return
    while n > 0
      yield val
      n -= 1

pexprand = |lo, hi, length|
  lo_iter = as_iter lo
  hi_iter = as_iter hi

  while length > 0
    hi_val = hi_iter.next()
    lo_val = lo_iter.next()

    if hi_val == () or lo_val == () then break

    yield exprand(lo_val, hi_val)

    length -= 1

pgauss = |mean, dev, length|
  mean_iter = as_iter mean
  dev_iter = as_iter dev

  while length > 0
    dev_val = dev_iter.next()
    mean_val = mean_iter.next()

    if mean_val == () or dev_val == () then break

    a = (-2 * random.number().ln()).sqrt()
    b = (2 * number.pi * random.number()).sin()
    yield a * b * dev_val + mean_val

    length -= 1

pgeom = |start, grow, length|
  grow_iter = as_iter grow
  outval = ()
  counter = 0

  while counter < length
    grow_val = grow_iter.next()

    if grow_val == () then break

    outval = start
    start = start * grow_val
    counter += 1
    yield outval

pwhite = |lo, hi, length|
  lo_iter = as_iter lo
  hi_iter = as_iter hi

  while length > 0
    hi_val = hi_iter.next()
    lo_val = lo_iter.next()

    if hi_val == () or lo_val == () then break

    length -= 1

    yield rrand lo_val, hi_val

plprand = |lo, hi, length|
  iter1 = pwhite lo, hi, length
  iter2 = pwhite lo, hi, length
  while length > 0
    length -= 1

    yield iter1.next().min iter2.next()

phprand = |lo, hi, length|
  iter1 = pwhite lo, hi, length
  iter2 = pwhite lo, hi, length
  while length > 0
    length -= 1

    yield iter1.next().max iter2.next()

pmeanrand = |lo, hi, length|
  iter1 = pwhite lo, hi, length
  iter2 = pwhite lo, hi, length
  while length > 0
    length -= 1

    yield (iter1.next() + iter2.next()) * 0.5

pindex = |list_pat, index_pat, repeats|
  index_iter = ()
  index = ()
  item = ()
  item_count = ()
  list_iter = as_iter list_pat
  while repeats > 0
    list = list_iter.next()
    if list == () then break
    index_iter = as_iter index_pat
    item_count = 0
    loop
      index = index_iter.next()
      if index == () then break
      item_count += 1
      item = list[index%list.size()]
      if koto.type(item) == "Iterator"
        loop
          next = item.next()
          if next == () then break
          yield next
      else
        yield item
    if item_count == 0 then break
    repeats -= 1

pfsm = |list, repeats|
  if list.is_empty() then return
  item = ()
  index = 0
  max_state = ((list.size() - 1) / 2).floor() - 1
  while repeats > 0
    index = 0
    loop
      index = (random.pick list[index]).clamp(0, max_state) * 2 + 2
      item = list[index - 1]
      if item == () then break
      if koto.type(item) == "Iterator"
        loop
          next = item.next()
          if next == () then break
          yield next
      else
        yield item
    repeats -= 1

place = |list, repeats, offset|
  offset_iter = as_iter offset
  # we don't use repeats here as it can be infinity, which won't work for
  # indexing
  repeat_num = 0 
  while repeats > 0
    offset = offset_iter.next()
    if offset == () then break
    for i in 0..list.size()
      item = list[(i + offset)%list.size()]
      if koto.type(item) == "List"
        item = item[repeat_num%item.size()]
      item = as_iter item
      yield item.next()
    repeat_num += 1
    repeats -= 1

ppoisson = |mean, length|
  mean_iter = as_iter mean
  while length > 0
    mean_val = mean_iter.next()
    if mean_val == () then break
    inc = 0
    test = random.number()
    temp = (-1 * mean_val).exp()
    while test > temp
      inc += 1
      test *= random.number()
    yield inc
    length -= 1

prand = |list, repeats|
  while repeats > 0
    item = random.pick list
    if item == () then break
    if koto.type(item) == "Iterator"
      loop
        next = item.next()
        if next == () then break
        yield next
    else
      yield item
    repeats -= 1

pseq = |list, repeats, offset|
  offset = as_iter offset
  while repeats > 0
    offset_next = offset.next()
    if offset_next == () then break
    for n in 0..list.size()
      event = list[(n + offset_next)%list.size()]
      if koto.type(event) == "Iterator"
        event = event.copy()
        loop
          next = event.next()
          if next == () then break
          yield next
      else
        yield event
    repeats -= 1


export @tests =

  @pre_test: ||
    random.seed 1

  @test as_iter: ||
    foo = as_iter 42
    bar = as_iter (0..=2).iter()

    for _ in 0..10
      assert_eq foo.next(), 42

    assert_eq bar.next(), 0
    assert_eq bar.next(), 1
    assert_eq bar.next(), 2
    assert_eq bar.next(), ()

  @test rrand: ||
    expected = [
      -1.2,
      3.469957416803331,
      -0.5,
      0.6902665517461255,
      -4.2,
      1.2452560333025064,
      -1.3,
      2.021086948798768,
      0.5944838253701086,
      -1.2,
      2.2390825654974087,
      -1.2,
      -0.6,
      -3.0,
      2.652270958284124,
      1.319258871135501,
      1.3631716977544475,
      2.5323785612426306,
      -3.5,
      -0.9
    ]
    for n in 0..20
      assert_near expected[n], rrand(5, -5), 0.1

  @test rand2: ||
    expected = [
      1.1870385830140222,
      -3.5,
      0.46718513136948303,
      -0.7,
      4.229941062594593,
      -1.2,
      1.3320208812485959,
      -2.0,
      -0.6,
      1.1719347584951194,
      -2.2,
      1.2042587403034766,
      0.6401493513957837,
      3.0197016659333222,
      -2.7,
      -1.3,
      -1.4,
      -2.5,
      3.4839803191568848,
      0.8963610833390785
    ]
    for item in expected
      assert_near rand2(5), item, 0.1

  @test fold: ||
    expected = [
      2.812961416985978,
      2.5300425831966695,
      2.467185131369483,
      2.6902665517461255,
      2.229941062594593,
      2.7547439666974936,
      2.667979118751404,
      2.021086948798768,
      2.5944838253701086,
      2.8280652415048806,
      2.2390825654974087,
      2.7957412596965234,
      2.6401493513957837,
      2.9802983340666778,
      2.6522709582841237,
      2.680741128864499,
      2.6368283022455525,
      2.5323785612426306,
      2.5160196808431152,
      2.8963610833390785,
    ]
    for item in expected
      assert_near fold(rand2(5), 2, 3), item, 0.000001

  @test round: ||
    assert_eq round(4.5, 0.5), 4.5
    assert_eq round(0.01, 0.5), 0
    assert_eq round(0.9, 0.5), 1.0

  @test pbeta: ||
    iter = pbeta 0, 1, 0.1, 0.1, infinity
    expected = [
      0.9999991445264916,
      0.9152024196110354,
      0.999875903336608,
      0.9994692080756311,
      0.03319654811950952,
      0.0003044408621467811,
      0.028751099344361247,
      0.011023335524190322,
      0.9797386852643469,
      0.9743803780361755,
      0.3407028163560437,
      0.9999999999999301,
      0.7631398280331377,
      0.9946581942463375,
      0.9816463243418938,
      0.25330909537521223,
      0.9999999221592342,
      0.9999148879416475,
      0.8848777651792713,
      0.9272571307795654
    ]

    for item in expected
      assert_near iter.next(), item, 0.000001

  @test pbrown: ||
    iter = pbrown 0, 1, 0.1, infinity
    expected = [
      0.5493047099653355,
      0.5586484125927252,
      0.5448430815578027,
      0.6294419028096946,
      0.6045367821436445,
      0.6311771997686164,
      0.5907554607926411,
      0.5788657842852389,
      0.6023044794551413,
      0.5575228281451932,
      0.5816080029512627,
      0.5944109899791784,
      0.6548050232978448,
      0.6017596041321623,
      0.5753744267094523,
      0.5481109927543634,
      0.49746342152951073,
      0.5671430279126484,
      0.58507024957943,
      0.5621729750717894,
    ]
    for item in expected
      assert_near iter.next(), item, 0.00001

  @test pgbrown: ||
    iter = pgbrown 0, 1, 0.2, infinity
    expected = [
      0.5328288166246906,
      0.5427860046523808,
      0.5277993237016826,
      0.6171017249870987,
      0.5863637391390359,
      0.6176056889206439,
      0.5676762970253886,
      0.5541773219602849,
      0.5801557085992849,
      0.5281950473033468,
      0.5536383873953493,
      0.567814837579307,
      0.6364000940185026,
      0.5688838745299202,
      0.5388636706051388,
      0.5094811224164588,
      0.4578731595458479,
      0.5216820026069645,
      0.5403866204075757,
      0.5156398588321188
    ]
    for item in expected
      assert_near iter.next(), item, 0.00001

  @test pcauchy: ||
    iter = pcauchy 0, 10, infinity
    expected = [
      -25.6,
      5.2147170741223885,
      -67.6,
      45.38893160257427,
      -2.5,
      24.244271410115708,
      -22.5,
      13.573803034087756,
      52.91991583580018,
      -25.9,
      11.790140905744481,
      -25.2,
      -49.1,
      -7.2,
      9.086266805541115,
      22.730323458806293,
      21.905407476147406,
      9.798601187194997,
      -5.2,
      -34.6,
    ]

    for item in expected
      assert_near iter.next(), item, 0.1

  @test pclump: ||
    iter = pclump 2, pseq([1,2,3], 1, 0)
    expected = [[1,2], [3], ()]
    for item in expected
      assert_eq iter.next(), item

  @test pclutch: ||
    iter = pclutch pseq([0,1,2,3], 2, 0), pseq([true, true, false], 3, 0)
    expected = [0, 1, 1, 2, 3, 3, 0, 1, 1, ()]
    for item in expected
      assert_eq iter.next(), item

  @test pconst: ||
    iter = pconst 5, pseq([1,2,0.5,0.1], 2, 0), 0.001
    expected = [1, 2, 0.5, 0.1, 1, 0.40000000000000036, ()]
    for item in expected
      assert_eq iter.next(), item

  @test pdup: ||
    iter = pdup 5, pseq([42,27], infinity, 0)
    expected = [42,42,42,42,42]

    for item in expected
      assert_eq iter.next(), item

    iter = pdup pseq([2,3,4],2,0), pseq([42,27], infinity, 0)
    expected = [
      42, 42, 27, 27, 27, 42, 42, 42, 42, 27, 27, 42, 42, 42, 27, 27, 27, 27
    ]

    for item in expected
      assert_eq iter.next(), item

  @test pexprand: ||
    iter = pexprand 0.0001, 1, infinity
    expected = [
      0.029841141583300028,
      0.0004092767114825923,
      0.01537708632863361,
      0.005295334257655042,
      0.49201282684887976,
      0.003176125003187975,
      0.03410423816335522,
      0.001554408707669678,
      0.005783709479337844,
      0.029428891472169295,
      0.0012716481793197704,
      0.030318205764975875,
      0.018032657769266016,
      0.1613915031052206,
      0.0008691437603582264,
      0.0029668558888765978,
      0.002849255012017592,
      0.0009706185241079233,
      0.24750964522715005,
      0.022832025106861588
    ]
    for item in expected
      assert_near iter.next(), item, 0.00001

  @test pgauss: ||
    iter = pgauss 0, 100, infinity
    expected = [
      80.35082837787117,
      46.18109205370832,
      28.22316915650585,
      91.30418859390468,
      -86.0,
      -110.1,
      -101.4,
      125.5030087331761,
      142.20088365392425,
      -30.6,
      72.64218281513229,
      4.087489843263244,
      -61.9,
      135.99953704404055,
      -4.8,
      -90.6,
      61.365490625579135,
      46.95618650843188,
      -48.5,
      44.024650157204086
    ]
    for item in expected
      assert_near iter.next(), item, 0.1

  @test pgeom: ||
    iter = pgeom 1, 1.1, infinity
    expected = [
      1,
      1.1,
      1.2100000000000002,
      1.3310000000000004,
      1.4641000000000006,
      1.6105100000000008,
      1.771561000000001,
      1.9487171000000014,
      2.1435888100000016,
      2.357947691000002,
      2.5937424601000023,
      2.853116706110003,
      3.1384283767210035,
      3.4522712143931042,
      3.797498335832415,
      4.177248169415656,
      4.594972986357222,
      5.054470284992944,
      5.559917313492239,
      6.115909044841463
    ]
    for item in expected
      assert_eq iter.next(), item

  @test pwhite: ||
    iter = pwhite 0, 1, infinity
    expected = [
      0.6187038583014022,
      0.1530042583196669,
      0.5467185131369483,
      0.4309733448253874,
      0.9229941062594592,
      0.37547439666974936,
      0.6332020881248596,
      0.2978913051201232,
      0.4405516174629891,
      0.6171934758495119,
      0.2760917434502591,
      0.6204258740303477,
      0.5640149351395783,
      0.8019701665933322,
      0.23477290417158758,
      0.36807411288644987,
      0.3636828302245553,
      0.24676214387573692,
      0.8483980319156884,
      0.5896361083339079
    ]
    for item in expected
      assert_near iter.next(), item, 0.0001

  @test plprand: ||
    iter = plprand 0, 1, infinity
    expected = [
      0.1530042583196669,
      0.4309733448253874,
      0.37547439666974936,
      0.2978913051201232,
      0.4405516174629891,
      0.2760917434502591,
      0.5640149351395783,
      0.23477290417158758,
      0.24676214387573692,
      0.5896361083339079,
      0.3855136274617973,
      0.04790208269762819,
      0.6365466664018155,
      0.15710685061085117,
      0.5102535624318508,
      0.6151173564933541,
      0.0712616454275049,
      0.33686989631048336,
      0.722317435472697,
      0.43311677419267547
    ]
    for item in expected
      assert_near iter.next(), item, 0.00001

  @test phprand: ||
    iter = phprand 0, 1, infinity
    expected = [
      0.6187038583014022,
      0.5467185131369483,
      0.9229941062594592,
      0.6332020881248596,
      0.6171934758495119,
      0.6204258740303477,
      0.8019701665933322,
      0.36807411288644987,
      0.3636828302245553,
      0.8483980319156884,
      0.41182270242523855,
      0.9905396731814841,
      0.7155524219707493,
      0.2649681662161876,
      0.7596424830971644,
      0.685341434428002,
      0.3662141599669775,
      0.8599226673317435,
      0.8857282675143859,
      0.55865794478581
    ]
    for item in expected
      assert_near iter.next(), item, 0.00001

  @test pmeanrand: ||
    iter = pmeanrand 0, 1, infinity
    expected = [
      0.38585405831053454,
      0.48884592898116785,
      0.6492342514646043,
      0.4655466966224914,
      0.5288725466562505,
      0.4482588087403034,
      0.6829925508664553,
      0.3014235085290187,
      0.3052224870501461,
      0.7190170701247982,
      0.3986681649435179,
      0.5192208779395562,
      0.6760495441862824,
      0.21103750841351937,
      0.6349480227645077,
      0.650229395460678,
      0.2187379026972412,
      0.5983962818211135,
      0.8040228514935415,
      0.49588735948924273
    ]
    for item in expected
      assert_near iter.next(), item, 0.00001

  @test pindex: ||
    iter = pindex(
      [7, 13, 12, 2, 2, 2, 5], 
      pseq([0, 0, 2, 0, 4, 6, 7], infinity, 0), 
      infinity)
    expected = [7, 7, 12, 7, 2, 5, 7, 7, 7, 12, 7, 2, 5, 7, 7, 7, 12, 7, 2, 5]
    for item in expected
      assert_eq iter.next(), item

  @test pfsm: ||
    iter = pfsm([
        [0,1],
        67, [0, 0, 3],
        72, [2],
        73, [0, 2],
        pseq([74, 75, 76, 77], 1, 0), [2, 3, 3],
        (), ()], infinity)
    expected = [72,73,73,73,73,73,73,67,67,67,67,74,75,76,77,73,73,73,67,73]

    for item in expected
      assert_eq iter.next(), item

  @test place: ||
    iter = place [1, [2, 5], [3, 6]], infinity, 0
    expected = [1,2,3,1,5,6,1,2]
    for item in expected
      assert_eq iter.next(), item

    iter = place(
      [1, pseq([2, 5], infinity, 0), pseq([3, 6], infinity, 0)], infinity, 0)
    for item in expected
      assert_eq iter.next(), item

  @test ppoisson: ||
    iter = ppoisson 10, infinity
    expected = [12,10,11,10,11,8,9,10,7,10,11,10,9,14,11,8,9,8,12,6]
    for item in expected
      assert_eq iter.next(), item

  @test prand: ||
    # FIXME will hang, because we can't copy iterators from generators
    # iter = prand [
      # pseq([0,1], 1, 0), 
      # pseq([2,3], 1, 0), 
      # pseq([4,5], 1, 0)
    # ], infinity

    iter = prand (0..10).to_list(), infinity
    expected = [6,1,5,4,9,6,4,6,6,8,2,2,8,4,0,7,6,1,7,5]
    for item in expected
      assert_eq iter.next(), item


  @test pseq: ||
    foo = pseq [0,1,2], infinity, 0
    expected = [0,1,2,0,1]
    for item in expected
      assert_eq foo.next(), item

    # FIXME won't work at the moment because koto can't copy iterators returned
    # by generators
    # foo = pseq [pseq([0,2], 2, 0), pseq([1,3], 2, 0)], 2, 0
    # expected = [0,2,0,2,1,3,1,3]
    # for _ in 0..2
      # for item in expected
        # assert_eq foo.next(), item

    foo = pseq [0,1,2], infinity, (pseq [0,1,4], 1, 0)
    expected = [0,1,2,1,2,0,1,2,0,()]
    for item in expected
      assert_eq foo.next(), item
